importScripts('./worker.js');let threadNo;async function importScript(a,b='Module'){if(b&&IWorker._global[b]&&IWorker._global[b].asm)return!1;'undefined'!=typeof Nimiq&&Nimiq._path&&(a=`${Nimiq._path}${a}`),'string'==typeof __dirname&&-1===a.indexOf('/')&&(a=`${__dirname}/${a}`);const c=IWorker._global[b]||{};return new Promise(async(d,f)=>{if(b)switch(typeof c.preRun){case'undefined':c.preRun=()=>d(!0);break;case'function':c.preRun=[c,()=>d(!0)];break;case'object':c.preRun.push(()=>d(!0));}'function'==typeof importScripts?(await new Promise(g=>{IWorker._moduleLoadedCallbacks[b]=g,importScripts(a)}),IWorker._global[b]=IWorker._global[b](c),!b&&d(!0)):'object'==typeof window?(await new Promise(g=>{IWorker._loadBrowserScript(a,g)}),IWorker._global[b]=IWorker._global[b](c),!b&&d(!0)):'function'==typeof require?(IWorker._global[b]=require(a)(c),!b&&d(!0)):f('No way to load scripts.')})}async function importWasm(a,b='Module'){return'undefined'!=typeof Nimiq&&Nimiq._path&&(a=`${Nimiq._path}${a}`),'string'==typeof __dirname&&-1===a.indexOf('/')&&(a=`${__dirname}/${a}`),IWorker._global.WebAssembly?new Promise(c=>{try{const d=new XMLHttpRequest;d.open('GET',a,!0),d.responseType='arraybuffer',d.onload=function(){IWorker._global[b]=IWorker._global[b]||{},IWorker._global[b].wasmBinary=d.response,c(!0)},d.onerror=function(){Log.w(IWorker,`Failed to access WebAssembly module ${a}`),c(!1)},d.send(null)}catch(d){Log.w(IWorker,`Failed to access WebAssembly module ${a}`),c(!1)}}):(Log.w(IWorker,'No support for WebAssembly available.'),Promise.resolve(!1))}async function initWasm(){(await importWasm('./worker-wasm.wasm'))?await importScript('./worker-wasm.js'):await importScript('./worker-js.js')}async function multiMine(a,b,c,d,f){const g=new Uint8Array(32);let h,i;try{const j=new SerialBuffer(a);j._writePos=j._view.byteLength,h=Module._malloc(g.length),i=Module._malloc(j.length),Module.HEAPU8.set(j,i);const k=Module._nimiq_hard_hash_target(h,i,j.length,b,c,d,512);if(k===d)return postMessage(['result',{startNonce:c,endNonce:d,timeNonce36:f}]),void postMessage(['ready',{}]);g.set(new Uint8Array(Module.HEAPU8.buffer,h,g.length)),postMessage(['result',{hash:g,nonce:k,timeNonce36:f}]),postMessage(['ready',{}])}catch(j){throw Log.w('multiMine',j),j}finally{h!=void 0&&Module._free(h),i!=void 0&&Module._free(i)}}async function initWorker(){await initWasm(),Log.i(`MinerWorker ${threadNo}`,`MinerWorker thread ${threadNo} init complete`),postMessage(['ready',{}])}onmessage=a=>{const b=a.data[0],c=a.data[1];switch(b){case'init':{threadNo=c.threadNo,initWorker();break}case'reready':{setTimeout(()=>{postMessage(['ready',{}])},c.time);break}case'mine':{multiMine(c.blockHeaderBuffer,c.nBits,c.startNonce,c.endNonce,c.timeNonce36);break}default:}};